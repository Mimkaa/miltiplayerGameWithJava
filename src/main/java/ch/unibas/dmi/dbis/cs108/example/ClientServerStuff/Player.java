package ch.unibas.dmi.dbis.cs108.example.ClientServerStuff;

import java.awt.Graphics;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.concurrent.ConcurrentLinkedQueue;

public class Player {
    private String name;
    private float x;
    private float y;
    private float radius;
    private float speed = 1.0f;
    
    // Internal fields for movement input.
    private float inputX = 0;
    private float inputY = 0;
    
    // Outgoing messages: these are generated by the player's own updates.
    // (In your update method, you already pass an external queue.)
    // For incoming messages, the player will hold its own queue.
    private final ConcurrentLinkedQueue<Message> incomingMessages = new ConcurrentLinkedQueue<>();

    public Player(String name, float x, float y, float radius) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    public String getName() {
        return name;
    }
    
    public float getX() {
        return x;
    }
    
    public float getY() {
        return y;
    }
    
    /**
     * Updates the player's position based on the stored input values.
     * If the player has moved and a provided messageQueue is not null,
     * a movement Message is enqueued into that external queue.
     *
     * @param messageQueue the external concurrent queue where the movement message will be added
     */
    public void update(ConcurrentLinkedQueue<Message> messageQueue) {
        float oldX = x;
        float oldY = y;
        x += inputX * speed;
        y += inputY * speed;
        
        // If the player moved, enqueue a movement message into the provided queue.
        if ((x != oldX || y != oldY) && messageQueue != null) {
            // Create a Message with type "MOVE" and parameters [newX, newY]
            Message moveMsg = new Message("MOVE", new Object[]{x, y}, null, new String[]{this.name});
            messageQueue.offer(moveMsg);
        }
    }
    
    /**
     * Processes incoming messages for this player.
     * This method polls the player's internal incoming message queue and updates
     * the player's state accordingly. For example, if a "MOVE" message is received,
     * it could update the player's position.
     */
    public void updateMessages() {
        Message msg;
        while ((msg = incomingMessages.poll()) != null) {
            if ("MOVE".equals(msg.getMessageType())) {
                // Assume parameters contain new position [x, y]
                Object[] params = msg.getParameters();
                if (params.length >= 2) {
                    // In a real scenario, add error handling for casting.
                    float newX = (params[0] instanceof Number) ? ((Number) params[0]).floatValue() : x;
                    float newY = (params[1] instanceof Number) ? ((Number) params[1]).floatValue() : y;
                    
                    // Update the player's position.
                    this.x = newX;
                    this.y = newY;
                    System.out.println("Processed MOVE message for " + name + ": new position x=" + newX + ", y=" + newY);
                }
            }
            // Add additional message types as needed.
        }
    }
    
    /**
     * Adds an incoming message to the player's queue.
     *
     * @param message the Message to add to the incoming queue
     */
    public void addIncomingMessage(Message message) {
        incomingMessages.offer(message);
    }
    
    /**
     * Draws the player on the given Graphics context.
     *
     * @param g the Graphics context for drawing
     */
    public void draw(Graphics g) {
        g.fillOval((int)(x - radius), (int)(y - radius), (int)(radius * 2), (int)(radius * 2));
    }
    
    /**
     * Provides a KeyAdapter that updates the player's input state.
     *
     * @return a KeyAdapter for handling key press and release events
     */
    public KeyAdapter getKeyListener() {
        return new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                switch (e.getKeyCode()) {
                    case KeyEvent.VK_W:
                        inputY = -1;
                        break;
                    case KeyEvent.VK_S:
                        inputY = 1;
                        break;
                    case KeyEvent.VK_A:
                        inputX = -1;
                        break;
                    case KeyEvent.VK_D:
                        inputX = 1;
                        break;
                }
            }

            @Override
            public void keyReleased(KeyEvent e) {
                switch (e.getKeyCode()) {
                    case KeyEvent.VK_W:
                    case KeyEvent.VK_S:
                        inputY = 0;
                        break;
                    case KeyEvent.VK_A:
                    case KeyEvent.VK_D:
                        inputX = 0;
                        break;
                }
            }
        };
    }
}
